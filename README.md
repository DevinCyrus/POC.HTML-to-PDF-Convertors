# HTML to PDF Converter POC

This repository is a **proof-of-concept (POC)** comparing different .NET SDKs for generating PDFs from HTML content.  
The project evaluates **PuppeteerSharp**, **PlaywrightSharp**, and **IronPDF**, with additional experiments using **Razor templating** for dynamic HTML generation.

---

### Overview

The goal of this POC is to:

- Compare performance, output size, and ease of integration between the three SDKs.  
- Evaluate how Razor templating can be used to dynamically generate report HTML before conversion.  
- Establish a baseline service-layer design for HTML-to-PDF conversion in a .NET API.  

---

### SDKs Tested

### PuppeteerSharp
- Wraps Chromium browser automation.  
- Handles Chromium installation automatically.  
- Good balance between control and ease-of-use.  

### PlaywrightSharp
- Similar to PuppeteerSharp but requires developers to manage browser binaries.  
- Provides the most fine-grained control over browser options.  

### IronPDF
- Commercial SDK (requires license for production use).  
- Embeds its own Chromium renderer (no browser management needed).  
- Simplest integration but less flexible.  

---

### Performance Logging

PDF generation metrics (duration + output size) are written to PdfPerfLogs/perf-results.csv.
This folder is ignored by Git via .gitignore.

---

### License

MIT (for this POC code).
Note: IronPDF is commercial software and requires a valid license for production use.

---

# POC Findings and Outcomes
<details>
<summary>Expand for Findings and Outcomes</summary>
<br>
The primary goal of this POC was to assess the accuracy, consistency, and maintainability of various HTML-to-PDF conversion tools. The focus was on ensuring that dynamic javascript, as well as visual elements such as charts, tables, and styling were faithfully represented, while also considering performance, deployment compatibility, cost/licensing and long-term support for the chosen solution.

### [Link to POC Repository](https://github.com/DevinCyrus/POC.HTML-to-PDF-Convertors)

### Requirements Criteria
<details>
<summary>The tools tested in this proof of concept (POC) will be evaluated against the following criteria:</summary>

1. **Rendering of Dynamic JavaScript Content**

    - Must correctly render charts and graphs generated by ApexCharts (or other JavaScript-based libraries).

    - All chart types (bar, pie, line, trend graphs, etc.) should appear consistently across exports.

    - Animations should resolve correctly before export, ensuring no missing or partially rendered sections.

2. **Styling and Layout Control**

    - Full support for CSS-based styling, including colors, fonts, and backgrounds.

    - Ability to preserve exact on-screen colors (avoid “print-friendly” color adjustments unless explicitly enabled).

    - Reliable support for **page breaks** (`page-break-before`, `page-break-after`, `page-break-inside`, and `@page` CSS rules).

    - Elements such as tables, headers, and charts should maintain alignment and spacing in the final PDF.

3. **Consistency and Reliability**

    - Output should remain stable across repeated runs with the same input HTML.

    - Avoid variation in rendering (e.g., missing bars, disappearing chart segments).

4. **Performance**

    - Conversion should complete within a reasonable time frame (<5 seconds for a single report under normal conditions).

    - Solution should have scalability.

5. **Deployment Feasibility**

    - Solution must work in the target hosting environment (e.g., Azure App Service or Dockerized .NET backend).

    - Dependencies should be manageable (no overly complex system-level installs).

6. **Licensing and Cost Considerations**

    - Must align with enterprise licensing requirements (e.g., free/open-source vs commercial license models).
</details>

### Evaluation Criteria
<details>
<summary>Each tool will be assessed based on the following measurable criteria:</summary>

1. **Accuracy of Dynamic Content Rendering**

    - All charts (bar, pie, line) must match the source HTML content.

    - No missing sections, truncated bars, or distorted elements.

    - JavaScript-generated content must render fully.

2. **Styling Fidelity**

    - Colors, fonts, backgrounds, and borders must match the HTML/CSS specification.

    - Page breaks and table layouts must align with the defined CSS rules.

    - Footers, headers, and fixed-position elements must appear correctly.

3. **Consistency Across Runs**

    - Repeated conversions of the same HTML must produce identical PDFs.

    - Any variation (e.g., missing chart segments, shifting layouts) counts as a failure.

4. **Performance Metrics**

    - Conversion speed measured in seconds per report.

5. **Deployment Compatibility**

    - Successfully runs in the target environment (Windows/Linux, Azure App Service, Docker).

    - No unresolved dependency or runtime errors.

6. **Usability and Maintainability**

    - Ease of integrating the solution.

    - Minimal configuration needed for styling, fonts, colors, and charts.

7. **License Compliance**

    - Verification that the chosen tool’s license allows enterprise use.
</details>

### Tools that Passed Initial Evaluation

- [Microsoft Playwright](https://playwright.dev/dotnet/docs/api/class-page#page-pdf)

- [IronPDF](https://ironpdf.com/docs/)

- [PuppeteerSharp](https://www.puppeteersharp.com/api/index.html#generate-pdf-files)

### Tools that Failed Initial Evaluation

<details>
<summary>Expand for list of tools that failed initial evaluation</summary>

| Tool/Package | Failure Reasons |
| --- | --- |
| SelectPDF | No native support for dynamic javascript. |
| OpenHtmlToPDF | No native support for dynamic javascript. |
| PeachPDF | No native support for dynamic javascript, it is also a very young package (24/12/2024). |
| Snappy | wkhtmltopdf based, which is known to be problematic with JavaScript. |
| DinkToPDF | wkhtmltopdf based, which is known to be problematic with JavaScript. |
| QuestPDF | FluentAPI style syntax which is very granular but too involved for the complexity of our anticipated report layouts.·         Not ideal for our use case, seems better suited for invoicing type applications that are less visually driven than our reports will be. |
</details>

## Comparison Table

| Feature / Criteria | PuppeteerSharp | Playwright | IronPDF |
| --- | --- | --- | --- |
| Underlying Engine | Chromium (via Puppeteer port for .NET) | Chromium, Firefox, WebKit (multi-browser support) | Embedded Chromium (abstracted from user) |
| License | Open-source (MIT) | Open-source (MIT) | Commercial |
| Integration Complexity | Moderate – requires managing browser lifecycle | Moderate – requires browser install/management as well as manageing lifecycles | Simple – library-based, no external browser |
| Performance | Very fast with singleton browser instances | Fast with singleton browser instances | Slower first-call (no persistent browser) |
| Browser Management | User-managed (can run singleton) | User-managed (singleton or per-context supported) | Hidden from user (no direct control) |
| JavaScript / SPA Handling | Strong, full JS execution support | Strong, with better isolation per test/page | Limited – can fail with heavy JS frameworks |
| Styling Consistency | High (matches Chrome print preview) | High (matches Chrome print preview) | Mixed – issues with Tailwind & external fonts |
| Charts & Graphics | Reliable once configured | Reliable once configured | Sometimes inconsistent with dynamic content and styling |
| Support | Community-driven (Node Puppeteer port) | Large, active Microsoft-backed community | Vendor supported |
| Maintainability | Actively maintained, but dependent on upstream sync | Actively maintained, Microsoft-backed, low risk | Vendor lock-in, ongoing license fees |

## Takeaways

All three solutions rely on **Chromium** under the hood to render HTML into PDF, but they differ in how much control and complexity they expose:

- **IronPDF** manages the browser entirely, embedding its own Chromium renderer into a simple .NET library—making it easy to use, though less flexible and sometimes less consistent with JavaScript-heavy pages.

- **PuppeteerSharp** provides direct but lower-level access to a headless Chromium instance, requiring manual management of pages and state.

- **Playwright** builds on a similar foundation but modernises the approach with cleaner APIs and per-request browser contexts for better isolation and reliability.

- **Licensing**: PuppeteerSharp and Playwright are open-source/free, while IronPDF requires commercial licensing.

### Integration & Setup

- Integration of all three packages is straightforward and not overly complicated.

- Playwright may involve additional overhead as **browser installation and management** is in the hands of the user.

### Performance

- For **PuppeteerSharp** and **Playwright**, singleton browser instances were used to avoid the overhead of repeatedly launching and closing Chromium.

    - Browsers are launched at application startup.

    - This improves performance, reduces memory/CPU usage, and ensures consistent context management across multiple PDF generations.

    - Individual tasks can still run in isolated pages or contexts.

        - **IronPDF** does not allow creating a singleton browser at startup.

    - As a result, the **first call** to the service has a significantly longer warmup time compared to the others.

\*_The below results are based on logs of a minimum of 300 requests per SDK, with the same 3 reports used for each SDK tested._

| SDK | Min. Duration (ms) | Max. Duration (ms) | Average Duration (ms) |
| --- | --- | --- | --- |
| PuppeteerSharp | 486 | 4299 | 1462.594 |
| Playwright | 508 | 7349 | 1894.481 |
| IronPDF | 744 | 6414 | 2131.098 |

| SDK | Min. File Size (KB) | Max. File Size (KB) | Average File Size (KB) |
| --- | --- | --- | --- |
| PuppeteerSharp | 243.498 | 834.675 | 596.6259 |
| Playwright | 205.703 | 782.647 | 535.198 |
| IronPDF | 104.157 | 813.178 | 522.5796 |

### Rendering Quality

- All three handled **charts, styling, and page breaks** reliably once configured.

- IronPDF fell short with some test reports that were **JavaScript-heavy**, used **Tailwind** and relied on **external fonts**

> [!WARNING]  
> It was also noted that the Line graphs from ApexChart had some issues with not rendering correctly, however this is nothing to do with the SDKs themselves, as this visual inconsistency is there when print previewing.
> I was unable to resolve it, but it is possible that some CSS fix the issue, alternatively Chart.js did not have this problem, so it could be an alternative to Apexcharts.

### HTML Report Design Considerations

- Reports should be designed from a **“PDF-first” perspective**, considering:

    - Page sizing (e.g., A4)

    - Background colours and contrasts, etc.

    - Page breaks

    - Use of physical CSS units (`mm`, `cm`, `pt`) for consistency

    - Element shadowing

- Potential issue

    - HTML reports can be tested by opening the report in **Chrome > Print Preview** before generating the PDF.

- Print Styling Resources

    - Page Breaks - [https://developer.mozilla.org/en-US/docs/Web/CSS/break-after](https://developer.mozilla.org/en-US/docs/Web/CSS/break-after)

    - Print Media - [https://developer.mozilla.org/en-US/docs/Web/CSS/CSS\_media\_queries/Printing](https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_media_queries/Printing)

    - Printer Friendly Pages CSS - [https://www.sitepoint.com/css-printer-friendly-pages/](https://www.sitepoint.com/css-printer-friendly-pages/)

    - Colours - [https://developer.mozilla.org/en-US/docs/Web/CSS/print-color-adjust](https://developer.mozilla.org/en-US/docs/Web/CSS/print-color-adjust)

- Any animations should be disabled for generation ( can be targeted with Print media selector css if animations are required when viewing the HTML version).

> [!NOTE]  
> HTML reports can be quickly tested by opening the report in **Chrome > Print Preview** before generating the PDF.

## Conclusions and Recommendations

Based on the above findings, I can find no justification for the licensing fees involved with IronPDF, as barring it having a significantly smaller file size for one of the reports (FinopsReport), this size difference was not present when generating the other reports.

I would definitely suggest going with either **Playwright** or **PuppeteerSharp** as the SDK of choice, leaning towards **_PuppeteerSharp_** as it will handle the Chromium browser installation for you where as Playwright does require the developer to maintain this.

Playwright does seem to offer the most fine grained control f its Chromium browser, but I could not find a need for that during this POC.

It is also important to note that all of these packages get implemented in much the same way, so it shouldn’t be too much of a process to switch to a different SDK if something arises further down the line that was not discovered in this POC.
</details>
